using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Linq;

namespace MongoDb.DatabaseProvider.Generators;

[Generator]
public class DbContextCollectionGenerator : ISourceGenerator
{
    private const string _autoGeneratedText = "";
    public void Execute(GeneratorExecutionContext context)
    {
        var list = new List<DataCollection>();
        if (context.SyntaxReceiver is not CollectionSyntaxReceiver csr)
        {
            return;
        }

        if (csr.Collections.Count == 0)
        {
            //GenerateContext(context, list);
            //GenerateServiceRegistration(context);
            return;
        }


        foreach (var collection in csr.Collections)
        {
            var className = collection.Identifier.ToString();
            var attributeSyntaxes = collection.AttributeLists.Select(x => x.Attributes).SelectMany(x => x).ToList();
            var selectedAttributeSyntaxes = attributeSyntaxes.Where(x => x.Name is IdentifierNameSyntax ins && ins.Identifier.ValueText == "MongoDbCollection").ToList().FirstOrDefault();

            var dataType = "Guid";

            if (selectedAttributeSyntaxes != null)
            {
                var firstArg = selectedAttributeSyntaxes.ArgumentList.GetAttributeProperty<string>("Type");

                if (firstArg != null)
                {
                    dataType = firstArg;
                }
            }

            var item = new DataCollection(className, ModifyName(className), GetNamespace(collection), dataType);
            list.Add(item);
            GenerateExtensionClass(context, item.ClassName, item.Name, item.Namespace, item.DataType);
        }

        GenerateContext(context, list);
        GenerateServiceRegistration(context);
    }

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new CollectionSyntaxReceiver());
    }

    private string ModifyName(string originName)
    {
        var l = originName.Length;

        if (originName.EndsWith("Entity"))
        {
            originName = originName.Substring(0, l - 6);
        }
        else if (originName.EndsWith("Model"))
        {
            originName = originName.Substring(0, l - 5);
        }
        else if (originName.EndsWith("Collection"))
        {
            originName = originName.Substring(0, l - 10);
        }

        l = originName.Length;
        if (originName.EndsWith("y"))
        {
            originName = originName.Substring(0, l - 1) + "ies";
        }
        else
        {
            originName = originName + "s";
        }

        return originName;
    }

    /// <summary>
    /// determine the namespace the class/enum/struct is declared in, if any
    /// </summary>
    /// <param name="syntax"></param>
    /// <returns></returns>
    static string GetNamespace(BaseTypeDeclarationSyntax syntax)
    {
        // If we don't have a namespace at all we'll return an empty string
        // This accounts for the "default namespace" case
        string nameSpace = string.Empty;

        // Get the containing syntax node for the type declaration
        // (could be a nested type, for example)
        SyntaxNode? potentialNamespaceParent = syntax.Parent;

        // Keep moving "out" of nested classes etc until we get to a namespace
        // or until we run out of parents
        while (potentialNamespaceParent != null &&
                potentialNamespaceParent is not NamespaceDeclarationSyntax
                && potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
        {
            potentialNamespaceParent = potentialNamespaceParent.Parent;
        }

        // Build up the final namespace by looping until we no longer have a namespace declaration
        if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
        {
            // We have a namespace. Use that as the type
            nameSpace = namespaceParent.Name.ToString();

            // Keep moving "out" of the namespace declarations until we 
            // run out of nested namespace declarations
            while (true)
            {
                if (namespaceParent.Parent is not NamespaceDeclarationSyntax parent)
                {
                    break;
                }

                // Add the outer namespace as a prefix to the final namespace
                nameSpace = $"{namespaceParent.Name}.{nameSpace}";
                namespaceParent = parent;
            }
        }

        // return the final namespace
        return nameSpace;
    }

    static string GetClassDefaultImplementation()
    {
        var template = @"private readonly IMongoDatabase _db;
    public MongoDbContext(string connectionString, string database)
    {
        var client = new MongoClient(connectionString);
        _db = client.GetDatabase(database);
        InitCollections();
    }
    public MongoDbContext(string database)
    {
        var client = new MongoClient();
        _db = client.GetDatabase(database);
        InitCollections();
    }
    public MongoDbContext(MongoClientSettings settings, string database)
    {
        var client = new MongoClient(settings);
        _db = client.GetDatabase(database);
        InitCollections();
    }
    public MongoDbContext(MongoUrl url, string database)
    {
        var client = new MongoClient(url);
        _db = client.GetDatabase(database);
        InitCollections();
    }

    public IMongoDatabase Db => _db;
";
        return template;
    }

    static void GenerateContext(GeneratorExecutionContext context, List<DataCollection> list)
    {
        var names = string.Join(", ", list.Select(x => $"\"{x.Name}s\""));
        var sb = new StringBuilder();
        sb.AppendLine("/// <auto-generated>")
            .AppendLine("/// This file was automatically generated from MongoDb.DatabaseProvider.Generators")
            .AppendLine("/// </auto-generated>")
            .AppendLine("using System.Diagnostics.CodeAnalysis;")
            .AppendLine("using MongoDB.Driver;")
            .AppendLine("namespace MongoDb.DatabaseProvider;")
            .AppendLine("public class MongoDbContext : IMongoDbContext")
            .AppendLine("{")
            .AppendLine(GetClassDefaultImplementation());


        sb.AppendLine($"\t[MemberNotNull({names})]");
        sb.AppendLine("\tvoid InitCollections()")
            .AppendLine("\t{");

        foreach (var data in list)
        {
            sb.AppendLine($"\t\t{data.Name}s = new MongoDbContextCollection<{data.Namespace}.{data.ClassName}>(_db.GetCollection<{data.Namespace}.{data.ClassName}>(\"{data.Name}s\"));");
        }

        sb.AppendLine("\t}").AppendLine();

        foreach (var (className, name, @namespace, dataType) in list)
        {
            sb.AppendLine($"\tpublic MongoDbContextCollection<{@namespace}.{className}> {name}s {{ get; private set; }}");
        }

        sb.AppendLine("}");

        context.AddSource($"MongoDbContext.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    static void GenerateExtensionClass(GeneratorExecutionContext context, string className, string name, string @namespace, string dataType)
    {
        var fullName = $"{@namespace}.{className}";
        var template = $@"{_autoGeneratedText}
using MongoDB.Bson;
using MongoDB.Driver;
using MongoDb.DatabaseProvider;

public static partial class MongoDbContext{name}sCollectionExtensions
{{
    public static void InsertRecord(this MongoDbContextCollection<{fullName}> collection, {fullName} record, InsertOneOptions? insertOneOptions = null)
    {{
        insertOneOptions ??= new InsertOneOptions {{ }};
        collection.Collection.InsertOne(record, insertOneOptions);
    }}

    public static Task InsertRecordAsync(this MongoDbContextCollection<{fullName}> collection, {fullName} record, InsertOneOptions? insertOneOptions = null, CancellationToken cancellationToken = default)
    {{
        insertOneOptions ??= new InsertOneOptions {{ }};
        return collection.Collection.InsertOneAsync(record, insertOneOptions, cancellationToken);
    }}

    public static void InsertRecords(this MongoDbContextCollection<{fullName}> collection, IEnumerable<{fullName}> records, InsertManyOptions? insertManyOptions = null)
    {{
        insertManyOptions ??= new InsertManyOptions {{ IsOrdered = false }};
        collection.Collection.InsertMany(records, insertManyOptions);
    }}
    public static Task InsertRecordsAsync(this MongoDbContextCollection<{fullName}> collection, IEnumerable<{fullName}> records, InsertManyOptions? insertManyOptions = null, CancellationToken cancellationToken = default)
    {{
        insertManyOptions ??= new InsertManyOptions {{ IsOrdered = false }};
        return collection.Collection.InsertManyAsync(records, insertManyOptions, cancellationToken);
    }}

    public static List<{fullName}> LoadRecords(this MongoDbContextCollection<{fullName}> collection)
    {{
        return collection.Collection.Find(new BsonDocument()).ToList();
    }}
    public static Task<List<{fullName}>> LoadRecordsAsync(this MongoDbContextCollection<{fullName}> collection, CancellationToken cancellationToken = default)
    {{
        return collection.Collection.Find(new BsonDocument()).ToListAsync(cancellationToken);
    }}

    public static {fullName} LoadRecordById(this MongoDbContextCollection<{fullName}> collection, {dataType} id)
    {{
        var filter = Builders<{fullName}>.Filter.Eq(""Id"", id);
        return collection.LoadRecordBy(filter);
    }}
    public static Task<{fullName}> LoadRecordByIdAsync(this MongoDbContextCollection<{fullName}> collection, {dataType} id)
    {{
        var filter = Builders<{fullName}>.Filter.Eq(""Id"", id);
        return collection.LoadRecordByAsync(filter);
    }}

    public static IEnumerable<{fullName}> LoadRecordsById(this MongoDbContextCollection<{fullName}> collection, params {dataType}[] ids)
    {{
        var filter = Builders<{fullName}>.Filter.AnyIn(""Id"", ids);
        return collection.LoadRecordsBy(filter);
    }}
    public static IEnumerable<{fullName}> LoadRecordsById(this MongoDbContextCollection<{fullName}> collection, IEnumerable<{dataType}[]> ids)
    {{
        var filter = Builders<{fullName}>.Filter.AnyIn(""Id"", ids);
        return collection.LoadRecordsBy(filter);
    }}
    public static Task<IEnumerable<{fullName}>> LoadRecordsByIdAsync(this MongoDbContextCollection<{fullName}> collection, params {dataType}[] ids)
    {{
        var filter = Builders<{fullName}>.Filter.AnyIn(""Id"", ids);
        return collection.LoadRecordsByAsync(filter);
    }}
    public static Task<IEnumerable<{fullName}>> LoadRecordsByIdAsync(this MongoDbContextCollection<{fullName}> collection, IEnumerable<{dataType}> ids)
    {{
        var filter = Builders<{fullName}>.Filter.AnyIn(""Id"", ids);
        return collection.LoadRecordsByAsync(filter);
    }}

    public static {fullName} LoadRecordBy(this MongoDbContextCollection<{fullName}> collection, FilterDefinition<{fullName}> filter)
    {{
        return collection.Collection.Find(filter).First();
    }}
    public static async Task<{fullName}> LoadRecordByAsync(this MongoDbContextCollection<{fullName}> collection, FilterDefinition<{fullName}> filter, FindOptions<{fullName}, {fullName}>? options = null, CancellationToken cancellationToken = default)
    {{
        var result = await collection.Collection.FindAsync(filter, options, cancellationToken);
        return await result.FirstAsync(cancellationToken);
    }}

    public static IEnumerable<{fullName}> LoadRecordsBy(this MongoDbContextCollection<{fullName}> collection, FilterDefinition<{fullName}> filter)
    {{
        return collection.Collection.Find(filter).ToList();
    }}
    public static async Task<IEnumerable<{fullName}>> LoadRecordsByAsync(this MongoDbContextCollection<{fullName}> collection, FilterDefinition<{fullName}> filter, FindOptions<{fullName}, {fullName}>? options = null, CancellationToken cancellationToken = default)
    {{
        var result = await collection.Collection.FindAsync(filter, options, cancellationToken);
        return await result.ToListAsync(cancellationToken);
    }}

    public static async Task<IEnumerable<{fullName}>> LoadRecordsByAsync<TEntity>(this MongoDbContextCollection<{fullName}> collection, (System.Linq.Expressions.Expression<Func<{fullName}, TEntity>> PropertyName, TEntity PropertyValue) filterValue, FindOptions<{fullName}, {fullName}>? options = null, CancellationToken cancellationToken = default)
    {{
        var filter = Builders<{fullName}>.Filter.Eq(filterValue.PropertyName, filterValue.PropertyValue);
        var result = await collection.Collection.FindAsync(filter, options, cancellationToken);
        return await result.ToListAsync(cancellationToken);
    }}

    public static ReplaceOneResult? UpsertRecord(this MongoDbContextCollection<{fullName}> collection, {dataType} id, {fullName} record, ReplaceOptions? replaceOptions = null)
    {{
        var filter = new BsonDocument(""_id"", {(dataType == "Guid" ? "var binData = new BsonBinaryData(id, GuidRepresentation.Standard);" : "id")});
        return collection.UpsertRecord(filter, record, replaceOptions);
    }}
    public static ReplaceOneResult? UpsertRecord(this MongoDbContextCollection<{fullName}> collection, FilterDefinition<{fullName}> filter, {fullName} record, ReplaceOptions? replaceOptions = null)
    {{
        replaceOptions ??= new ReplaceOptions {{ IsUpsert = true }};
        var result = collection.Collection.ReplaceOne(filter, record, replaceOptions);
        return result;
    }}

    public static Task<ReplaceOneResult?> UpsertRecordAsync(this MongoDbContextCollection<{fullName}> collection, {dataType} id, {fullName} record, ReplaceOptions? replaceOptions = null, CancellationToken cancellationToken = default)
    {{
        var filter = new BsonDocument(""_id"", {(dataType == "Guid" ? "var binData = new BsonBinaryData(id, GuidRepresentation.Standard);" : "id")});
        return collection.UpsertRecordAsync(filter, record, replaceOptions, cancellationToken);
    }}
    public static Task<ReplaceOneResult?> UpsertRecordAsync(this MongoDbContextCollection<{fullName}> collection, FilterDefinition<{fullName}> filter, {fullName} record, ReplaceOptions? replaceOptions = null, CancellationToken cancellationToken = default)
    {{
        replaceOptions ??= new ReplaceOptions {{ IsUpsert = true }};
        var result = collection.Collection.ReplaceOneAsync(filter, record, replaceOptions, cancellationToken);
        return result;
    }}

    public static DeleteResult? DeleteRecord(this MongoDbContextCollection<{fullName}> collection, {dataType} id)
    {{
        var filter = Builders<{fullName}>.Filter.Eq(""Id"", id);
        var result = collection.Collection.DeleteOne(filter);
        return result;
    }}
    public static Task<DeleteResult?> DeleteRecordAsync(this MongoDbContextCollection<{fullName}> collection, {dataType} id, CancellationToken cancellationToken = default)
    {{
        var filter = Builders<{fullName}>.Filter.Eq(""Id"", id);
        return collection.Collection.DeleteOneAsync(filter, cancellationToken);
    }}
}}";

        context.AddSource($"MongoDbContextCollection{className}Extensions.g.cs", SourceText.From(template, Encoding.UTF8));
    }

    static void GenerateServiceRegistration(GeneratorExecutionContext context)
    {
        var template = @$"{_autoGeneratedText}
using Microsoft.Extensions.DependencyInjection;
using MongoDB.Driver;

namespace MongoDb.DatabaseProvider;
public static class ServiceRegistrationExtension
{{
    public static IServiceCollection AddMongoDbProvider(this IServiceCollection services, string connectionString, string database)
    {{
        services.AddTransient<MongoDbContext>((serviceCollection) =>
        {{
            var dbContext = new MongoDbContext(connectionString, database);
            return dbContext;
        }});

        return services;
    }}

    public static IServiceCollection AddMongoDbProvider(this IServiceCollection services, string database)
    {{
        services.AddTransient<MongoDbContext>((serviceCollection) =>
        {{
            var dbContext = new MongoDbContext(database);
            return dbContext;
        }});

        return services;
    }}

    public static IServiceCollection AddMongoDbProvider(this IServiceCollection services, MongoClientSettings settings, string database)
    {{
        services.AddTransient<MongoDbContext>((serviceCollection) =>
        {{
            var dbContext = new MongoDbContext(settings, database);
            return dbContext;
        }});

        return services;
    }}

    public static IServiceCollection AddMongoDbProvider(this IServiceCollection services, MongoUrl url, string database)
    {{
        services.AddTransient<MongoDbContext>((serviceCollection) =>
        {{
            var dbContext = new MongoDbContext(url, database);
            return dbContext;
        }});

        return services;
    }}
}}";

        context.AddSource($"ServiceRegistrationExtension.g.cs", SourceText.From(template, Encoding.UTF8));
    }
}

internal record struct DataCollection(string ClassName, string Name, string Namespace, string DataType);

